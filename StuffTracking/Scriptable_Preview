//week 16 unity 2017 talk link : https://www.youtube.com/watch?app=desktop&v=raQ3iHhE_Kk
//project files : http://www.roboryantron.com/2017/10/unite-2017-game-architecture-with.html
//unity 2016 talk link : https://www.youtube.com/watch?v=6vmRwLYWNRo
//Note: Destroy() and DestroyImmediate() only remove the C++ side, C# side must have all references gone (might only be for ScriptableObjects)
//bitbucket link is defunt : https://bitbucket.org/richardfine/scriptableobjectdemo/

/*
How work:
You write the script (C#) with the [CreateAssetMenu]
You create an asset, name it (because.)
Set the value; this is like using instances
So while each asset might be edited and change everything (haven't tested)
Each asset with ScriptableObject won't change if a ScriptableObject of the same kind is changed
*/

/*
Focus on data
Editable w/o code
Only one outcome/expectable outcomes

Similar to MonoBehaviour w/o Transform (same type in c++ layer)
typically saved as .asset, but can be created at runtime and can also have multiple in one

uses the Unity Inspector like an Injector

BiggerThing can reference and edit DataType (and/or DataReferences)
while OtherThing can view the same DataType

can be used for Events as well
(check about 37 minutes in)

"RuntimeSets" keep track of a list of things, mostly a type of object
multiple types of thign may require multiple lists and have them be added in to each one
different items may not need it, but flyiong vs. grounded enemies might
Also good for renderers, mini map stuff

Can also be used like Enums (Elements and/or their extensions and what they beat/lose to)

You !! CAN !! write entire objects or more inside a ScriptableObject, they aren't just "data buckets"

Inventory Example:
-ScriptableObject Master List
-ScriptableObject per item(? just to avoid changing everything)
--can have different inventories for each scene

Systems !! CAN !! interact with other systems


Shared (values used across multiple objects) v non-shared (exclusive to one instance/type) states
MonoBehaviours create sub-file granularity (possible conflicts and issues when editing)
Hard to figure out where callbacks are coming and going
ScriptableObjects can't be attached to GameObjects/Prefabs, doesn't get most callbacks, and can be serialized and inspected like MonoBehaviour

only callbacks are OnEnable(), OnDisable(), and Destroy()

Usage ends up being for seperating shared states (ScriptableObject) from non-shared (MonoBehaviour)

"dies" on deletion or Resources.UnloadUnusedAssets() //removes anything not referenced

Enum pattern uses Empty SO's, binds them to assets, and treats SO like dictionary keys

Delegates;
Scenes can be pased into ScriptableObjects so its methods can do work on the scene (called from the scene)

SOs and Monobehaviours should work in tandem, not serve as absolute replacements
supposed to seperate tasks so people can change elements without crashing everything
*/

[CreateAssetMenu]
//automates asset creation

public class DataType : ScriptableObject{
  public type Value;
}

//will this work?

public class BiggerThing : ScriptableObject{
  public DataType ValueA;
  public DataReference ValueB
}


//different file ?


//gets broken down into bytes that can be turned into a file or back to its object
[Serializable]

public class DataReference{
  public bool UseConstant = bool;
  public type Constant;
  public DataType Vari;
  
  public type Value{
    get{ UseConstant ? Constant : Vari.Value;}
  }
}
//


//different file ?


//abstract template

[CreateAssetMenu (menuName="Tab Name/Asset Name")]
public class GameEvents : ScriptableObject{
  access List<GameEventListener> listeners = new List<GameEventListener>();
  
  //backwards because some events might remove themselves from the list
  public void Raise(){
    for(int i = listeners.Count - 1; i>=0; i--){
      listeners[i].OnEventRaised();
    }
  }
  
  /*
  methods that add and remove listeners
  */
}


//different file ?


public class GameEventListener : MonoBehaviour{
  access GameEvents Event;
  access UnityEvent Respond;
  
  private void OnEnable(){
    Event.RegisterEvent(this);
  }
  //private void OnDisable
  
  public void OnEventRaised(){
    Respond.Invoke();
  }
}


//different file ?

public abstract class RuntimeSet<T> : ScriptableObject {
  public List<T> Things = new List<T>();
  
  public void Add(T thing){
    if(!Things.Contains(thing)){
      Things.Add(thing);
    }
  }
  public void Rem(T thing){
    if(Things.Contains(thing)){
      Things.Remove(thing);
    }
  }
}

//different file ?

//[CreateAssetMenu]
access class Dynamite : ScriptableObject{
  access T ValueA;
  access T ValueB;
  
  access return DestroyContact(T collider){ //? I don't know I've never used one before
    collider.Destroy();
  }
}



//different talk

//creates instance in-memory
ScriptableObject.CreateInstance<BiggerThing>();

//binding to asset files
AssetDatabase.CreateAsset(); //or
AssetBatabase.AddObjectToAsset();


//Double serialization


class LevelLayout : ScriptableObject{
  access Vector2[] thingPosA;
  access Vector2[] thingPosB;
  access Vector2 startPos;
}

//loading from built-In
level = someBundle.LoadAsset<LevelLayout>("levelName.asset");

//loading from JSON
level = CreateInstance<LevelLayout>();
var jsonThing = File.ReadAllText("custom.json");
JsonUtility.FromJsonOverwrite(jsonTing, level);


//Reload proof singletons


class SomeSingle : ScriptableObject{
  private static SomeSingle _inst;
  
  public static SomeSingle Instance{
    get{
      if(!_inst){
        _inst = Resources.FindObjectOfType<SomeSingle>();
        //takes advantage of some data being in the C++ side for ScriptableObjects
        
      } if(!_inst){
        _inst = CreateInstance<SomeSingle>();
      }
      return _inst;
    }
  }
}


//Delegating


abstract class Collectable : ScriptableObject{
  public abstract void DoThing(GameObject collector);
}

//other class
public void OnTriggerEnter(GameObject collector){
  Destroy(gameObject);
  collectableObject.DoThing(collector);
}

/*
public class ValueChange : Collectable{
  public type whatever;
  public override void DoThing(GameObject collector){
    collector.GetComponent<ChangeThingThing>().value += whatever;
    //or
    Instantiate(whatever, collector.position, collector.rotation);
  }
}
*/



//actually looking at Unite 2017 files
//scripts (like above) were put into own folder, different from assets (which were created by them)

//taken straight from file
namespace RoboRyanTron.Unite2017.Variables
{
    [CreateAssetMenu]
    public class FloatVariable : ScriptableObject
    {
#if UNITY_EDITOR
        [Multiline]
        public string DeveloperDescription = "";
#endif
        public float Value;

        public void SetValue(float value)
        {
            Value = value;
        }

        public void SetValue(FloatVariable value)
        {
            Value = value.Value;
        }

        public void ApplyChange(float amount)
        {
            Value += amount;
        }

        public void ApplyChange(FloatVariable amount)
        {
            Value += amount.Value;
        }
    }
}
//should be obvious you'd want getters and setters, except there are no getters


public class KeyboardMover : MonoBehaviour
    {
        [Serializable]
	//having this on lets you change the MoveAxis Parameters inside the inspector
	//perhaps lets you treat non-object classes like one?

        public class MoveAxis
        {
            public KeyCode Positive;
            public KeyCode Negative;

            public MoveAxis(KeyCode positive, KeyCode negative)
            {
                Positive = positive;
                Negative = negative;
            }

            public static implicit operator float(MoveAxis axis)
            {
                return (Input.GetKey(axis.Positive)
                    ? 1.0f : 0.0f) -
                    (Input.GetKey(axis.Negative)
                    ? 1.0f : 0.0f);
            }
        }

        public FloatVariable MoveRate;
        public MoveAxis Horizontal = new MoveAxis(KeyCode.D, KeyCode.A);
        public MoveAxis Vertical = new MoveAxis(KeyCode.W, KeyCode.S);

        private void Update()
        {
            Vector3 moveNormal = new Vector3(Horizontal, Vertical, 0.0f).normalized;

            transform.position += moveNormal*Time.deltaTime*MoveRate.Value;
        }
    }


//extedning an abstract RunTimeSet
//v can be put over any class, including an abstract parent apparently
[CreateAssetMenu]
public class ThingSet : RunTimeSet<Thing>{
//that's all that's neccesary, but just in case you want it
	public void override Add(Thing t){ //I actually don't know, as VisualStudio is not displaying any errors
		//something else
	}

	private int DoThing(){
		//something new
	}
}


//UI thing for the Sets demo

using UnityEngine;
using UnityEngine.UI;

namespace RoboRyanTron.Unite2017.Sets
{
    public class ThingMonitor : MonoBehaviour
    {
        public ThingRuntimeSet Set;

        public Text Text;

        private int previousCount = -1;

        private void OnEnable()
        {
            UpdateText();
        }

        private void Update()
        {
            if (previousCount != Set.Items.Count)
            {
                UpdateText();
                previousCount = Set.Items.Count;
            }
        }

        public void UpdateText()
        {
            Text.text = "There are " + Set.Items.Count + " things.";
        }
    }
}

[CreateAssetMenu]
    public class GameEvent : ScriptableObject
    {
        /// <summary>
        /// The list of listeners that this event will notify if it is raised.
        /// </summary>
        private readonly List<GameEventListener> eventListeners = 
            new List<GameEventListener>();

        public void Raise()
        {
            for(int i = eventListeners.Count -1; i >= 0; i--)
                eventListeners[i].OnEventRaised();
        }

        public void RegisterListener(GameEventListener listener)
        {
            if (!eventListeners.Contains(listener))
                eventListeners.Add(listener);
        }

        public void UnregisterListener(GameEventListener listener)
        {
            if (eventListeners.Contains(listener))
                eventListeners.Remove(listener);
        }
    }


public class GameEventListener : MonoBehaviour
    {
        [Tooltip("Event to register with.")]
        public GameEvent Event;

        [Tooltip("Response to invoke when Event is raised.")]
        public UnityEvent Response;

        private void OnEnable()
        {
            Event.RegisterListener(this);
        }

        private void OnDisable()
        {
            Event.UnregisterListener(this);
        }

        public void OnEventRaised()
        {
            Response.Invoke();
        }
    }

//how events work (w/ scriptable objects)
/*
Have the GameEvent and GameEventListener scripts (Scriptable and MonoBehaviour respectively)
Create an asset out of the GameEvent (call it whatever)
In an event thing (such as a button's), have the function to be called the GameEvent's Raise()
put the Asset (Whatever) inside the parameter thing/holder
Create an Object and add the GEListener
Add the Asset to the GameEvent variable thing
Under the Respone() event tab, attach the script/event/object to happen, then the function
When the object with the component is initialized/eneabled, the OnEnable() command calls
placing it into the Event list, letting it be called when the Event asset is triggered
*/


//Enums

public class Elemental : MonoBehaviour
    {
        [Tooltip("Element represented by this elemental.")]
        public AttackElement Element;

        [Tooltip("Text to fill in with the element name.")]
        public Text Label;

        private void OnEnable()
        {
            if(Label != null)
                Label.text = Element.name;
        }

        private void OnTriggerEnter(Collider other)
        {
            Elemental e = other.gameObject.GetComponent<Elemental>();
            if (e != null)
            {
                if (e.Element.DefeatedElements.Contains(Element))
                    Destroy(gameObject);
            }
        }
    }

//where AttackElement is a ScriptableObject that has just a List of itself
// and is turned into an Asset where other AttackElements are put in